from fastapi import FastAPI, HTTPException, UploadFile, File
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.responses import HTMLResponse, FileResponse
from fastapi.requests import Request
from pydantic import BaseModel, Field
from typing import Optional, Literal
import uvicorn
import os
import sys
import tempfile
import base64
import time
import torch
import numpy as np
import soundfile as sf
import yaml
import gc
from functools import lru_cache

# Add parent directory to path to import VieNeu-TTS modules
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from vieneu_tts import VieNeuTTS, FastVieNeuTTS
from utils.core_utils import split_text_into_chunks

app = FastAPI(title="VieNeu-TTS Web API", version="1.0.0")

# Mount static files
app.mount("/static", StaticFiles(directory="static"), name="static")

# Templates
templates = Jinja2Templates(directory="templates")

# --- CONFIGURATION ---
CONFIG_PATH = os.path.join(os.path.dirname(os.path.dirname(__file__)), "config.yaml")
try:
    with open(CONFIG_PATH, "r", encoding="utf-8") as f:
        _config = yaml.safe_load(f) or {}
except Exception as e:
    raise RuntimeError(f"Cannot read config.yaml: {e}")

BACKBONE_CONFIGS = _config.get("backbone_configs", {})
CODEC_CONFIGS = _config.get("codec_configs", {})
VOICE_SAMPLES = _config.get("voice_samples", {})

_text_settings = _config.get("text_settings", {})
MAX_CHARS_PER_CHUNK = _text_settings.get("max_chars_per_chunk", 256)
MAX_TOTAL_CHARS_STANDARD = 500
MAX_TOTAL_CHARS_STREAMING = _text_settings.get("max_total_chars_streaming", 3000)

if not BACKBONE_CONFIGS or not CODEC_CONFIGS:
    raise ValueError("config.yaml missing backbone_configs or codec_configs")
if not VOICE_SAMPLES:
    raise ValueError("config.yaml missing voice_samples")

# Global model state
tts = None
current_backbone = None
current_codec = None
current_device = None
model_loaded = False
using_lmdeploy = False

# Cache for reference texts
@lru_cache(maxsize=32)
def get_ref_text_cached(text_path: str) -> str:
    """Cache reference text loading"""
    with open(text_path, "r", encoding="utf-8") as f:
        return f.read()

def cleanup_gpu_memory():
    """Cleanup GPU memory"""
    if torch.cuda.is_available():
        torch.cuda.empty_cache()
        torch.cuda.synchronize()
    gc.collect()

def should_use_lmdeploy(backbone_choice: str, device_choice: str) -> bool:
    """Determine if we should use LMDeploy backend"""
    if "gguf" in backbone_choice.lower():
        return False
    
    if device_choice.lower() == "auto":
        has_gpu = torch.cuda.is_available()
    elif device_choice.lower() == "cuda":
        has_gpu = torch.cuda.is_available()
    else:
        has_gpu = False
    
    return has_gpu


# --- PYDANTIC MODELS ---
class ModelLoadRequest(BaseModel):
    backbone: str = Field(..., description="Backbone model choice")
    codec: str = Field(..., description="Codec model choice")
    device: Literal["auto", "cpu", "cuda"] = Field(default="auto", description="Device selection")
    enable_triton: bool = Field(default=True, description="Enable Triton compilation")
    max_batch_size: int = Field(default=8, ge=1, le=16, description="Maximum batch size for processing")


class TTSRequest(BaseModel):
    text: str = Field(..., description="Text to synthesize", max_length=3000)
    mode: Literal["preset", "custom"] = Field(..., description="Generation mode")
    voice_id: Optional[str] = Field(None, description="Preset voice ID (required for preset mode)")
    reference_audio: Optional[str] = Field(None, description="Base64 encoded audio (required for custom mode)")
    reference_text: Optional[str] = Field(None, description="Reference audio transcription (required for custom mode)")
    language: str = Field(default="vi", description="Language code")
    generation_mode: Literal["standard", "streaming"] = Field(default="standard", description="Generation mode")
    use_batch: bool = Field(default=True, description="Enable batch processing")


class VoiceInfo(BaseModel):
    id: str
    name: str
    description: str
    region: Optional[str] = None
    gender: Optional[str] = None
    audio_sample: Optional[str] = None


# Placeholder voice data
VOICES = [
    {
        "id": "binh",
        "name": "Bình",
        "description": {"vi": "Nam miền Bắc", "en": "Northern Male"},
        "thumbnail": None
    },
    {
        "id": "doan",
        "name": "Đoan",
        "description": {"vi": "Nữ miền Nam", "en": "Southern Female"},
        "thumbnail": None
    },
    {
        "id": "dung",
        "name": "Dung",
        "description": {"vi": "Nữ miền Nam", "en": "Southern Female"},
        "thumbnail": None
    },
    {
        "id": "huong",
        "name": "Hương",
        "description": {"vi": "Nữ miền Bắc", "en": "Northern Female"},
        "thumbnail": None
    },
    {
        "id": "ly",
        "name": "Ly",
        "description": {"vi": "Nữ miền Bắc", "en": "Northern Female"},
        "thumbnail": None
    },
    {
        "id": "ngoc",
        "name": "Ngọc",
        "description": {"vi": "Nữ miền Bắc", "en": "Northern Female"},
        "thumbnail": None
    },
    {
        "id": "nguyen",
        "name": "Nguyên",
        "description": {"vi": "Nam miền Nam", "en": "Southern Male"},
        "thumbnail": None
    },
    {
        "id": "son",
        "name": "Sơn",
        "description": {"vi": "Nam miền Nam", "en": "Southern Male"},
        "thumbnail": None
    },
    {
        "id": "tuyen",
        "name": "Tuyên",
        "description": {"vi": "Nam miền Bắc", "en": "Northern Male"},
        "thumbnail": None
    },
    {
        "id": "vinh",
        "name": "Vĩnh",
        "description": {"vi": "Nam miền Nam", "en": "Southern Male"},
        "thumbnail": None
    }
]


@app.get("/", response_class=HTMLResponse)
async def root(request: Request):
    """Serve the main UI page"""
    return templates.TemplateResponse("index.html", {"request": request})


@app.get("/api/voices")
async def get_voices(language: str = "vi"):
    """Get list of available voices"""
    voices_with_localized_desc = []
    for voice in VOICES:
        voices_with_localized_desc.append({
            "id": voice["id"],
            "name": voice["name"],
            "description": voice["description"].get(language, voice["description"]["vi"]),
            "thumbnail": voice["thumbnail"]
        })
    return {"voices": voices_with_localized_desc}


@app.post("/api/generate")
async def generate_speech(request: TTSRequest):
    """
    Generate speech from text (placeholder endpoint)
    This will be implemented with actual TTS logic later
    """
    if len(request.text) > 500:
        raise HTTPException(status_code=400, detail="Text exceeds 500 characters limit")
    
    if not request.text.strip():
        raise HTTPException(status_code=400, detail="Text cannot be empty")
    
    # TODO: Implement actual TTS generation
    # For now, return a placeholder response
    return {
        "status": "success",
        "message": "Speech generation endpoint (to be implemented)",
        "audio_url": "/static/audio/placeholder.wav",
        "text": request.text,
        "voice_id": request.voice_id
    }


@app.get("/api/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "VieNeu-TTS API"}


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000, reload=True)
